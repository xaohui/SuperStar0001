name: å¤šè´¦å·åˆ·è¯¾

on: 
  push:
    branches: [ main ]  
  schedule:
    - cron: "0 8 * * *"

jobs: 
  MultiAccountStudy:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        account: [1, 2]
      max-parallel: 2
    
    steps:
      - name: æ‹·è´ä»£ç 
        uses: actions/checkout@v4

      - name: è®¾ç½®pythonç¯å¢ƒ
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: å®‰è£…ä¾èµ–åŒ…
        run: |
          pip install -r ./requirements.txt 
      
      - name: ä¸ºè´¦å· ${{ matrix.account }} åˆ›å»ºä¿®å¤ç‰ˆé…ç½®æ–‡ä»¶
        run: |
          cat > config_${{ matrix.account }}.ini << EOF
          [common]
          username = ${{ secrets[format('USERNAME{0}', matrix.account)] }}
          password = ${{ secrets[format('PASSWORD{0}', matrix.account)] }}
          course_list = 255731372
          speed = 1.0
          notopen_action = continue
          
          [tiku]
          # AIæä¾›å•†è®¾ç½®
          provider = AI
          endpoint = https://api.deepseek.com/v1
          key = ${{ secrets.DEEPSEEK_API_KEY }}
          model = deepseek-chat
          http_proxy = 
          
          # æ—¶é—´æ§åˆ¶è®¾ç½® (å¢åŠ å¤„ç†æ—¶é—´å‡å°‘æ—¶åºé—®é¢˜)
          min_interval_seconds = 5
          delay = 10.0
          
          # ç­”é¢˜ç²¾åº¦è®¾ç½®
          cover_rate = 0.98
          disable = false
          submit = true
          tiku_path = ./api/data/tiku.json
          
          # ç­”æ¡ˆéªŒè¯è®¾ç½®
          enable_answer_validation = true
          validation_retry_count = 2
          double_check_answer = true
          answer_format_strict = true
          
          # åˆ¤æ–­é¢˜å…³é”®è¯åˆ—è¡¨
          true_list = æ­£ç¡®,å¯¹,æ˜¯,true,True,æ˜¯,å¯¹,æ­£ç¡®,âˆš,T,t,1
          false_list = é”™è¯¯,é”™,å¦,false,False,é”™,é”™è¯¯,Ã—,F,f,0
          EOF
          
          echo "è´¦å· ${{ matrix.account }} ä¿®å¤ç‰ˆé…ç½®æ–‡ä»¶åˆ›å»ºå®Œæˆ"
          echo "é…ç½®æ–‡ä»¶å†…å®¹é¢„è§ˆ (éšè—æ•æ„Ÿä¿¡æ¯):"
          cat config_${{ matrix.account }}.ini | grep -v -E "(password|key) = " || true

      - name: éªŒè¯é…ç½®æ–‡ä»¶æ ¼å¼
        run: |
          echo "éªŒè¯é…ç½®æ–‡ä»¶æ ¼å¼..."
          python -c "
          import configparser
          config = configparser.ConfigParser()
          try:
              config.read('config_${{ matrix.account }}.ini', encoding='utf-8')
              print('âœ… é…ç½®æ–‡ä»¶æ ¼å¼æ­£ç¡®')
              
              # éªŒè¯æ•°å€¼ç±»å‹é…ç½®
              delay = config.getfloat('tiku', 'delay')
              min_interval = config.getfloat('tiku', 'min_interval_seconds')
              cover_rate = config.getfloat('tiku', 'cover_rate')
              
              print(f'âœ… æ•°å€¼é…ç½®è¯»å–æˆåŠŸ: delay={delay}, min_interval={min_interval}, cover_rate={cover_rate}')
              
          except Exception as e:
              print(f'âŒ é…ç½®æ–‡ä»¶æ ¼å¼é”™è¯¯: {e}')
              exit(1)
          "

      - name: åˆ›å»ºç­”æ¡ˆéªŒè¯è„šæœ¬ (æ— æ³¨é‡Šé—®é¢˜ç‰ˆæœ¬)
        run: |
          cat > answer_validator.py << 'EOF'
          import re
          import time
          import logging
          
          logging.basicConfig(level=logging.INFO)
          logger = logging.getLogger("AnswerValidator")
          
          class AnswerValidator:
              def __init__(self):
                  self.true_keywords = ['æ­£ç¡®', 'å¯¹', 'æ˜¯', 'true', 'true', 'âˆš', 't', '1']
                  self.false_keywords = ['é”™è¯¯', 'é”™', 'å¦', 'false', 'false', 'Ã—', 'f', '0']
              
              def clean_answer(self, raw_answer):
                  if not raw_answer:
                      return ""
                  
                  answer = str(raw_answer).strip()
                  
                  option_match = self._extract_options(answer)
                  if option_match:
                      return option_match
                  
                  judge_result = self._normalize_judgment(answer)
                  if judge_result:
                      return judge_result
                  
                  return answer.strip()
              
              def _extract_options(self, answer):
                  cleaned = re.sub(r'^(ç­”æ¡ˆ|é€‰é¡¹|é€‰æ‹©|æ­£ç¡®ç­”æ¡ˆ)[ï¼š:\s]*', '', answer, flags=re.IGNORECASE)
                  
                  option_match = re.findall(r'[ABCDabcd]', cleaned.upper())
                  if option_match:
                      unique_options = sorted(set(option_match))
                      return ''.join(unique_options)
                  
                  chinese_match = re.findall(r'[ä¸€äºŒä¸‰å››]', cleaned)
                  if chinese_match:
                      chinese_to_letter = {'ä¸€': 'A', 'äºŒ': 'B', 'ä¸‰': 'C', 'å››': 'D'}
                      return ''.join(chinese_to_letter.get(c, '') for c in chinese_match)
                  
                  return ""
              
              def _normalize_judgment(self, answer):
                  answer_lower = answer.lower().strip()
                  
                  for keyword in self.true_keywords:
                      if keyword in answer_lower:
                          return "æ­£ç¡®"
                  
                  for keyword in self.false_keywords:
                      if keyword in answer_lower:
                          return "é”™è¯¯"
                  
                  return ""
              
              def validate_answer_before_submit(self, recognized_answer, page_options):
                  if not recognized_answer:
                      return False, "", "ç­”æ¡ˆä¸ºç©º"
                  
                  cleaned_answer = self.clean_answer(recognized_answer)
                  
                  if not self._is_valid_format(cleaned_answer):
                      return False, cleaned_answer, f"ç­”æ¡ˆæ ¼å¼æ— æ•ˆ: {cleaned_answer}"
                  
                  if not self._is_in_options(cleaned_answer, page_options):
                      return False, cleaned_answer, f"ç­”æ¡ˆä¸åœ¨é€‰é¡¹èŒƒå›´å†…: {cleaned_answer}"
                  
                  return True, cleaned_answer, "éªŒè¯é€šè¿‡"
              
              def _is_valid_format(self, answer):
                  if not answer:
                      return False
                  
                  if answer in ["æ­£ç¡®", "é”™è¯¯"]:
                      return True
                  
                  if re.match(r'^[ABCD]+$', answer):
                      return True
                  
                  return False
              
              def _is_in_options(self, answer, page_options):
                  if not page_options:
                      return True
                  
                  if answer in ["æ­£ç¡®", "é”™è¯¯"]:
                      return True
                  
                  for char in answer:
                      if char not in "ABCD":
                          return False
                  
                  return True
          
          if __name__ == "__main__":
              validator = AnswerValidator()
              test_cases = ["A", "ç­”æ¡ˆï¼šB", "é€‰é¡¹C", "æ­£ç¡®", "é”™è¯¯", "æˆ‘è§‰å¾—é€‰A", "BC", "ç­”æ¡ˆåº”è¯¥æ˜¯D"]
              for test in test_cases:
                  result = validator.clean_answer(test)
                  print(f"åŸå§‹: '{test}' -> æ¸…ç†å: '{result}'")
          EOF

      - name: è¿è¡Œä¿®å¤ç‰ˆåˆ·è¯¾è„šæœ¬ - è´¦å· ${{ matrix.account }}
        env:
          DEEPSEEK_API_KEY: ${{ secrets.DEEPSEEK_API_KEY }}
        run: |
          echo "å¼€å§‹æ‰§è¡Œè´¦å· ${{ matrix.account }} çš„ä¿®å¤ç‰ˆåˆ·è¯¾ä»»åŠ¡..."
          LOG_FILE="fixed_study_log_account_${{ matrix.account }}_$(date +%Y%m%d_%H%M%S).txt"
          
          # å¤åˆ¶éªŒè¯è„šæœ¬
          cp answer_validator.py ./api/ || true
          cp answer_validator.py ./ || true
          
          # è¿è¡Œä¸»ç¨‹åº
          python main.py -c config_${{ matrix.account }}.ini 2>&1 | tee $LOG_FILE
          
          EXIT_CODE=${PIPESTATUS[0]}
          
          if [ $EXIT_CODE -eq 0 ]; then
            echo "âœ… è´¦å· ${{ matrix.account }} åˆ·è¯¾ä»»åŠ¡å®Œæˆ"
            
            # æ£€æŸ¥ç­”æ¡ˆåŒ¹é…æƒ…å†µ
            ANSWER_MATCHES=$(grep -c "ç­”æ¡ˆ.*åŒ¹é…\|answer.*match" $LOG_FILE 2>/dev/null || echo "0")
            ANSWER_ERRORS=$(grep -c "ç­”æ¡ˆ.*é”™è¯¯\|answer.*error" $LOG_FILE 2>/dev/null || echo "0")
            
            echo "ç­”æ¡ˆåŒ¹é…ç»Ÿè®¡:"
            echo "  - æˆåŠŸåŒ¹é…: $ANSWER_MATCHES"
            echo "  - åŒ¹é…é”™è¯¯: $ANSWER_ERRORS"
            
          else
            echo "âŒ è´¦å· ${{ matrix.account }} åˆ·è¯¾ä»»åŠ¡å¤±è´¥"
            echo "LOG_FILE=$LOG_FILE" >> $GITHUB_ENV
          fi

      - name: ä¸Šä¼ ä¿®å¤ç‰ˆæ—¥å¿—
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: fixed-logs-account-${{ matrix.account }}
          path: |
            fixed_study_log_account_${{ matrix.account }}_*.txt
          retention-days: 7

  ConfigFixSummary:
    runs-on: ubuntu-latest
    needs: MultiAccountStudy
    if: always()
    steps:
      - name: é…ç½®ä¿®å¤æ€»ç»“
        run: |
          echo "ğŸ”§ é…ç½®æ–‡ä»¶ä¿®å¤æ€»ç»“"
          echo "========================"
          echo "é—®é¢˜åŸå› : é…ç½®æ–‡ä»¶ä¸­æ•°å€¼å­—æ®µåé¢æ·»åŠ äº†æ³¨é‡Š"
          echo "é”™è¯¯ç¤ºä¾‹: delay = 10.0 # å¢åŠ å»¶è¿Ÿ"
          echo "æ­£ç¡®ç¤ºä¾‹: delay = 10.0"
          echo ""
          echo "ä¿®å¤æªæ–½:"
          echo "âœ… ç§»é™¤é…ç½®å€¼åé¢çš„è¡Œå†…æ³¨é‡Š"
          echo "âœ… å°†æ³¨é‡Šå•ç‹¬æ”¾åœ¨é…ç½®é¡¹ä¸Šæ–¹"
          echo "âœ… æ·»åŠ é…ç½®æ–‡ä»¶æ ¼å¼éªŒè¯æ­¥éª¤"
          echo "âœ… ä½¿ç”¨çº¯æ•°å€¼é…ç½®å‚æ•°"
          echo ""
          echo "é¢„é˜²æªæ–½:"
          echo "ğŸ“ é…ç½®æ–‡ä»¶åªåŒ…å«é”®å€¼å¯¹ï¼Œæ³¨é‡Šå•ç‹¬æˆè¡Œ"
          echo "ğŸ“ æ•°å€¼é…ç½®ä¸ä½¿ç”¨ä»»ä½•é¢å¤–å­—ç¬¦"
          echo "ğŸ“ æ·»åŠ é…ç½®éªŒè¯æ­¥éª¤ç¡®ä¿æ ¼å¼æ­£ç¡®"
