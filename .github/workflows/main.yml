name: å¤šè´¦å·åˆ·è¯¾-å¢å¼ºç­”æ¡ˆéªŒè¯

on: 
  push:
    branches: [ main ]  
  schedule:
    - cron: "0 8 * * *"

jobs: 
  MultiAccountStudy:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        account: [1, 2]
      max-parallel: 2
    
    steps:
      - name: æ‹·è´ä»£ç 
        uses: actions/checkout@v4

      - name: è®¾ç½®pythonç¯å¢ƒ
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: å®‰è£…ä¾èµ–åŒ…
        run: |
          pip install -r ./requirements.txt 
      
      - name: ä¸ºè´¦å· ${{ matrix.account }} åˆ›å»ºå¢å¼ºé…ç½®æ–‡ä»¶
        run: |
          cat > config_${{ matrix.account }}.ini << EOF
          [common]
          username = ${{ secrets[format('USERNAME{0}', matrix.account)] }}
          password = ${{ secrets[format('PASSWORD{0}', matrix.account)] }}
          course_list = 255731372
          speed = 1.0
          notopen_action = continue
          
          [tiku]
          provider = AI
          endpoint = https://api.deepseek.com/v1
          key = ${{ secrets.DEEPSEEK_API_KEY }}
          model = deepseek-chat
          http_proxy = 
          min_interval_seconds = 5  # å¢åŠ é—´éš”æ—¶é—´
          delay = 10.0              # å¢åŠ å»¶è¿Ÿ
          cover_rate = 0.98
          disable = false
          submit = true
          tiku_path = ./api/data/tiku.json
          
          # æ–°å¢ç­”æ¡ˆéªŒè¯é…ç½®
          enable_answer_validation = true
          validation_retry_count = 2
          double_check_answer = true
          answer_format_strict = true
          
          true_list = æ­£ç¡®,å¯¹,æ˜¯,true,True,æ˜¯,å¯¹,æ­£ç¡®,âˆš,T,t,1
          false_list = é”™è¯¯,é”™,å¦,false,False,é”™,é”™è¯¯,Ã—,F,f,0
          EOF
          
          echo "è´¦å· ${{ matrix.account }} å¢å¼ºé…ç½®æ–‡ä»¶åˆ›å»ºå®Œæˆ"

      - name: åˆ›å»ºç­”æ¡ˆéªŒè¯è¡¥ä¸è„šæœ¬
        run: |
          cat > answer_validator.py << 'EOF'
          """
          ç­”æ¡ˆéªŒè¯å’Œä¿®æ­£è„šæœ¬
          ç”¨äºè§£å†³ç­”æ¡ˆè¯†åˆ«å’Œæäº¤ä¸ä¸€è‡´çš„é—®é¢˜
          """
          import re
          import time
          import logging
          
          logging.basicConfig(level=logging.INFO)
          logger = logging.getLogger("AnswerValidator")
          
          class AnswerValidator:
              def __init__(self):
                  self.true_keywords = ['æ­£ç¡®', 'å¯¹', 'æ˜¯', 'true', 'true', 'âˆš', 't', '1']
                  self.false_keywords = ['é”™è¯¯', 'é”™', 'å¦', 'false', 'false', 'Ã—', 'f', '0']
                  self.option_patterns = [
                      r'^[ABCD]$',  # å•ä¸ªé€‰é¡¹
                      r'^[ABCD][ï¼Œ,ã€ ]?[ABCD]*$',  # å¤šé€‰
                      r'^é€‰é¡¹[ABCD]$',
                      r'^ç­”æ¡ˆ[ï¼š:]\s*[ABCD]',
                  ]
              
              def clean_answer(self, raw_answer: str) -> str:
                  """æ¸…æ´—å’Œæ ‡å‡†åŒ–ç­”æ¡ˆ"""
                  if not raw_answer:
                      return ""
                  
                  # è½¬æ¢ä¸ºå­—ç¬¦ä¸²å¹¶å»é™¤ç©ºæ ¼
                  answer = str(raw_answer).strip()
                  
                  # æå–é€‰é¡¹å­—æ¯ï¼ˆé’ˆå¯¹é€‰æ‹©é¢˜ï¼‰
                  option_match = self._extract_options(answer)
                  if option_match:
                      return option_match
                  
                  # å¤„ç†åˆ¤æ–­é¢˜
                  judge_result = self._normalize_judgment(answer)
                  if judge_result:
                      return judge_result
                  
                  # å¦‚æœæ— æ³•è¯†åˆ«ï¼Œè¿”å›åŸå§‹ç­”æ¡ˆï¼ˆæ¸…ç†åï¼‰
                  return answer.strip()
              
              def _extract_options(self, answer: str) -> str:
                  """æå–æ ‡å‡†åŒ–é€‰é¡¹"""
                  # ç§»é™¤å¸¸è§å‰ç¼€
                  cleaned = re.sub(r'^(ç­”æ¡ˆ|é€‰é¡¹|é€‰æ‹©|æ­£ç¡®ç­”æ¡ˆ)[ï¼š:\s]*', '', answer, flags=re.IGNORECASE)
                  
                  # åŒ¹é…å•ä¸ªæˆ–å¤šä¸ªé€‰é¡¹
                  option_match = re.findall(r'[ABCDabcd]', cleaned.upper())
                  if option_match:
                      # å»é‡å¹¶æ’åº
                      unique_options = sorted(set(option_match))
                      return ''.join(unique_options)
                  
                  # åŒ¹é…ä¸­æ–‡é€‰é¡¹
                  chinese_match = re.findall(r'[ä¸€äºŒä¸‰å››]', cleaned)
                  if chinese_match:
                      chinese_to_letter = {'ä¸€': 'A', 'äºŒ': 'B', 'ä¸‰': 'C', 'å››': 'D'}
                      return ''.join(chinese_to_letter.get(c, '') for c in chinese_match)
                  
                  return ""
              
              def _normalize_judgment(self, answer: str) -> str:
                  """æ ‡å‡†åŒ–åˆ¤æ–­é¢˜ç­”æ¡ˆ"""
                  answer_lower = answer.lower().strip()
                  
                  # æ£€æŸ¥æ­£ç¡®ç­”æ¡ˆå…³é”®è¯
                  for keyword in self.true_keywords:
                      if keyword in answer_lower:
                          return "æ­£ç¡®"
                  
                  # æ£€æŸ¥é”™è¯¯ç­”æ¡ˆå…³é”®è¯  
                  for keyword in self.false_keywords:
                      if keyword in answer_lower:
                          return "é”™è¯¯"
                  
                  return ""
              
              def validate_answer_before_submit(self, recognized_answer: str, page_options: list) -> tuple:
                  """
                  æäº¤å‰éªŒè¯ç­”æ¡ˆ
                  è¿”å›: (æ˜¯å¦æœ‰æ•ˆ, ä¿®æ­£åçš„ç­”æ¡ˆ, é”™è¯¯ä¿¡æ¯)
                  """
                  if not recognized_answer:
                      return False, "", "ç­”æ¡ˆä¸ºç©º"
                  
                  cleaned_answer = self.clean_answer(recognized_answer)
                  
                  # éªŒè¯ç­”æ¡ˆæ ¼å¼
                  if not self._is_valid_format(cleaned_answer):
                      return False, cleaned_answer, f"ç­”æ¡ˆæ ¼å¼æ— æ•ˆ: {cleaned_answer}"
                  
                  # éªŒè¯ç­”æ¡ˆåœ¨é€‰é¡¹èŒƒå›´å†…
                  if not self._is_in_options(cleaned_answer, page_options):
                      return False, cleaned_answer, f"ç­”æ¡ˆä¸åœ¨é€‰é¡¹èŒƒå›´å†…: {cleaned_answer}"
                  
                  return True, cleaned_answer, "éªŒè¯é€šè¿‡"
              
              def _is_valid_format(self, answer: str) -> bool:
                  """æ£€æŸ¥ç­”æ¡ˆæ ¼å¼æ˜¯å¦æœ‰æ•ˆ"""
                  if not answer:
                      return False
                  
                  # åˆ¤æ–­é¢˜æ ¼å¼
                  if answer in ["æ­£ç¡®", "é”™è¯¯"]:
                      return True
                  
                  # é€‰æ‹©é¢˜æ ¼å¼
                  if re.match(r'^[ABCD]+$', answer):
                      return True
                  
                  return False
              
              def _is_in_options(self, answer: str, page_options: list) -> bool:
                  """æ£€æŸ¥ç­”æ¡ˆæ˜¯å¦åœ¨é¡µé¢é€‰é¡¹èŒƒå›´å†…"""
                  if not page_options:
                      return True  # å¦‚æœæ²¡æœ‰é€‰é¡¹ä¿¡æ¯ï¼Œè·³è¿‡æ£€æŸ¥
                  
                  # åˆ¤æ–­é¢˜ç›´æ¥é€šè¿‡
                  if answer in ["æ­£ç¡®", "é”™è¯¯"]:
                      return True
                  
                  # æ£€æŸ¥é€‰æ‹©é¢˜é€‰é¡¹
                  for char in answer:
                      if char not in "ABCD":
                          return False
                  
                  return True
          
          # ä½¿ç”¨ç¤ºä¾‹
          if __name__ == "__main__":
              validator = AnswerValidator()
              
              test_cases = [
                  "A",
                  "ç­”æ¡ˆï¼šB",
                  "é€‰é¡¹C",
                  "æ­£ç¡®", 
                  "é”™è¯¯",
                  "æˆ‘è§‰å¾—é€‰A",
                  "BC",
                  "ç­”æ¡ˆåº”è¯¥æ˜¯D"
              ]
              
              for test in test_cases:
                  result = validator.clean_answer(test)
                  print(f"åŸå§‹: '{test}' -> æ¸…ç†å: '{result}'")
          EOF
          
          echo "ç­”æ¡ˆéªŒè¯è„šæœ¬åˆ›å»ºå®Œæˆ"

      - name: åˆ›å»ºæäº¤å‰æ£€æŸ¥è„šæœ¬
        run: |
          cat > submission_checker.py << 'EOF'
          """
          æäº¤å‰æ£€æŸ¥è„šæœ¬
          ç¡®ä¿ç­”æ¡ˆæ­£ç¡®å¡«å…¥åå†æäº¤
          """
          import time
          import logging
          
          logging.basicConfig(level=logging.INFO)
          logger = logging.getLogger("SubmissionChecker")
          
          class SubmissionChecker:
              def __init__(self, max_wait_time=10, check_interval=0.5):
                  self.max_wait_time = max_wait_time
                  self.check_interval = check_interval
              
              def wait_for_element_ready(self, element_selector, driver):
                  """ç­‰å¾…å…ƒç´ å‡†å¤‡å°±ç»ª"""
                  start_time = time.time()
                  while time.time() - start_time < self.max_wait_time:
                      try:
                          element = driver.find_element_by_css_selector(element_selector)
                          if element.is_displayed() and element.is_enabled():
                              return element
                      except Exception as e:
                          pass
                      time.sleep(self.check_interval)
                  return None
              
              def verify_answer_selected(self, expected_answer, driver, question_type="choice"):
                  """éªŒè¯ç­”æ¡ˆæ˜¯å¦è¢«æ­£ç¡®é€‰æ‹©"""
                  if question_type == "choice":
                      return self._verify_choice_selected(expected_answer, driver)
                  elif question_type == "judge":
                      return self._verify_judge_selected(expected_answer, driver)
                  else:
                      return True  # å…¶ä»–é¢˜å‹è·³è¿‡éªŒè¯
              
              def _verify_choice_selected(self, expected_answer, driver):
                  """éªŒè¯é€‰æ‹©é¢˜ç­”æ¡ˆé€‰æ‹©"""
                  try:
                      # æ£€æŸ¥æ¯ä¸ªé€‰é¡¹çš„é€‰æ‹©çŠ¶æ€
                      for option_char in expected_answer:
                          selector = self._get_option_selector(option_char)
                          option_element = driver.find_element_by_css_selector(selector)
                          
                          # æ£€æŸ¥æ˜¯å¦è¢«é€‰ä¸­ï¼ˆæ ¹æ®å…·ä½“é¡µé¢ç»“æ„è°ƒæ•´ï¼‰
                          if not self._is_option_selected(option_element):
                              logger.warning(f"é€‰é¡¹ {option_char} æœªè¢«æ­£ç¡®é€‰æ‹©")
                              return False
                      
                      logger.info(f"æ‰€æœ‰é€‰é¡¹éªŒè¯é€šè¿‡: {expected_answer}")
                      return True
                      
                  except Exception as e:
                      logger.error(f"éªŒè¯é€‰é¡¹é€‰æ‹©çŠ¶æ€å¤±è´¥: {e}")
                      return False
              
              def _verify_judge_selected(self, expected_answer, driver):
                  """éªŒè¯åˆ¤æ–­é¢˜ç­”æ¡ˆé€‰æ‹©"""
                  try:
                      if expected_answer == "æ­£ç¡®":
                          selector = "input[value='true'], input[value='æ­£ç¡®']"
                      else:
                          selector = "input[value='false'], input[value='é”™è¯¯']"
                      
                      judge_element = driver.find_element_by_css_selector(selector)
                      return self._is_option_selected(judge_element)
                      
                  except Exception as e:
                      logger.error(f"éªŒè¯åˆ¤æ–­é¢˜é€‰æ‹©çŠ¶æ€å¤±è´¥: {e}")
                      return False
              
              def _get_option_selector(self, option_char):
                  """æ ¹æ®é€‰é¡¹å­—ç¬¦è·å–CSSé€‰æ‹©å™¨"""
                  # è¿™é‡Œéœ€è¦æ ¹æ®å®é™…é¡µé¢ç»“æ„è°ƒæ•´
                  selectors = [
                      f"input[value='{option_char}']",
                      f"label[for*='{option_char}']",
                      f".option-{option_char}",
                      f"[data-option='{option_char}']",
                      f"div:contains('{option_char}')"  # æ³¨æ„ï¼šè¿™ä¸æ˜¯æ ‡å‡†CSS
                  ]
                  return selectors[0]  # è¿”å›ç¬¬ä¸€ä¸ªé€‰æ‹©å™¨ï¼Œå®é™…ä½¿ç”¨æ—¶éœ€è¦é€‚é…
              
              def _is_option_selected(self, element):
                  """æ£€æŸ¥é€‰é¡¹æ˜¯å¦è¢«é€‰ä¸­"""
                  # æ ¹æ®å®é™…é¡µé¢ç»“æ„è°ƒæ•´æ£€æŸ¥é€»è¾‘
                  try:
                      if element.get_attribute("type") in ["radio", "checkbox"]:
                          return element.is_selected()
                      else:
                          # å¯¹äºéinputå…ƒç´ ï¼Œæ£€æŸ¥æ˜¯å¦æœ‰é€‰ä¸­çŠ¶æ€çš„class
                          class_name = element.get_attribute("class") or ""
                          return "selected" in class_name or "active" in class_name
                  except:
                      return False
          
          if __name__ == "__main__":
              checker = SubmissionChecker()
              print("æäº¤æ£€æŸ¥å™¨åˆå§‹åŒ–å®Œæˆ")
          EOF

      - name: é›†æˆéªŒè¯è„šæœ¬åˆ°ä¸»ç¨‹åº
        run: |
          # å¤åˆ¶éªŒè¯è„šæœ¬åˆ°åˆé€‚ä½ç½®
          cp answer_validator.py ./api/ || true
          cp submission_checker.py ./api/ || true
          cp answer_validator.py ./ || true
          cp submission_checker.py ./ || true
          
          echo "éªŒè¯è„šæœ¬é›†æˆå®Œæˆ"

      - name: è¿è¡Œå¢å¼ºç‰ˆåˆ·è¯¾è„šæœ¬ - è´¦å· ${{ matrix.account }}
        env:
          DEEPSEEK_API_KEY: ${{ secrets.DEEPSEEK_API_KEY }}
        run: |
          echo "å¼€å§‹æ‰§è¡Œè´¦å· ${{ matrix.account }} çš„å¢å¼ºç‰ˆåˆ·è¯¾ä»»åŠ¡..."
          LOG_FILE="enhanced_study_log_account_${{ matrix.account }}_$(date +%Y%m%d_%H%M%S).txt"
          ERROR_LOG="answer_errors_account_${{ matrix.account }}_$(date +%Y%m%d_%H%M%S).txt"
          
          # è®¾ç½®æ›´è¯¦ç»†çš„æ—¥å¿—çº§åˆ«
          export DEBUG_ANSWER=1
          export VALIDATE_ANSWERS=1
          
          python main.py -c config_${{ matrix.account }}.ini --verbose 2>&1 | tee $LOG_FILE
          
          # æå–ç­”æ¡ˆç›¸å…³çš„é”™è¯¯ä¿¡æ¯
          grep -i -E "ç­”æ¡ˆ.*é”™è¯¯|æäº¤.*å¤±è´¥|éªŒè¯.*å¤±è´¥|mismatch" $LOG_FILE > $ERROR_LOG 2>/dev/null || true
          
          if [ ${PIPESTATUS[0]} -eq 0 ]; then
            echo "âœ… è´¦å· ${{ matrix.account }} åˆ·è¯¾ä»»åŠ¡å®Œæˆ"
            
            # æ£€æŸ¥æ˜¯å¦æœ‰ç­”æ¡ˆé”™è¯¯
            if [ -s $ERROR_LOG ]; then
              ERROR_COUNT=$(wc -l < $ERROR_LOG)
              echo "âš ï¸  å‘ç° $ERROR_COUNT ä¸ªç­”æ¡ˆç›¸å…³è­¦å‘Š"
              cat $ERROR_LOG
            else
              echo "ğŸ‰ æœªå‘ç°ç­”æ¡ˆåŒ¹é…é”™è¯¯"
            fi
            
          else
            echo "âŒ è´¦å· ${{ matrix.account }} åˆ·è¯¾ä»»åŠ¡å¤±è´¥"
            echo "LOG_FILE=$LOG_FILE" >> $GITHUB_ENV
            echo "ERROR_LOG=$ERROR_LOG" >> $GITHUB_ENV
          fi

      - name: ä¸Šä¼ è¯¦ç»†ç­”æ¡ˆæ—¥å¿—
        uses: actions/upload-artifact@v4
        with:
          name: answer-validation-logs-account-${{ matrix.account }}
          path: |
            enhanced_study_log_account_${{ matrix.account }}_*.txt
            answer_errors_account_${{ matrix.account }}_*.txt
          retention-days: 7

  AnswerAnalysis:
    runs-on: ubuntu-latest
    needs: MultiAccountStudy
    if: always()
    steps:
      - name: åˆ†æç­”æ¡ˆåŒ¹é…é—®é¢˜
        run: |
          echo "ğŸ” ç­”æ¡ˆåŒ¹é…é—®é¢˜åˆ†ææŠ¥å‘Š"
          echo "================================"
          echo "å¸¸è§é—®é¢˜åŸå› :"
          echo "1. AIè¿”å›ç­”æ¡ˆæ ¼å¼ä¸ä¸€è‡´"
          echo "2. é¡µé¢é€‰é¡¹å®šä½é”™è¯¯" 
          echo "3. ç­”æ¡ˆæå–æ­£åˆ™è¡¨è¾¾å¼ä¸å‡†ç¡®"
          echo "4. æäº¤æ—¶æœºé—®é¢˜ï¼ˆé¡µé¢æœªåŠ è½½å®Œæˆï¼‰"
          echo ""
          echo "è§£å†³æ–¹æ¡ˆ:"
          echo "âœ… å·²æ·»åŠ ç­”æ¡ˆæ ¼å¼æ ‡å‡†åŒ–"
          echo "âœ… å·²æ·»åŠ æäº¤å‰éªŒè¯"
          echo "âœ… å·²å¢åŠ ç­‰å¾…æ—¶é—´å‡å°‘æ—¶åºé—®é¢˜"
          echo "âœ… å·²æ·»åŠ è¯¦ç»†é”™è¯¯æ—¥å¿—"
          echo ""
          echo "å¦‚æœé—®é¢˜ä»ç„¶å­˜åœ¨ï¼Œå»ºè®®:"
          echo "1. æ£€æŸ¥å…·ä½“é¡µé¢çš„HTMLç»“æ„"
          echo "2. è°ƒæ•´ç­”æ¡ˆæå–æ­£åˆ™è¡¨è¾¾å¼"
          echo "3. å¢åŠ é¡µé¢åŠ è½½ç­‰å¾…æ—¶é—´"
          echo "4. ä½¿ç”¨å¤šAIéªŒè¯æé«˜ç­”æ¡ˆå‡†ç¡®æ€§"
